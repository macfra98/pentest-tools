/* =========== INFO ABOUT PROGRAM =========== */
/* Author: macfra                             */
/* Description:                               */
/* this program is used to download & add,    */
/* download & update or remove specific files */
/* and programs used for enumeration, privesc,*/
/* and exploitation within this repo.         */
////////////////////////////////////////////////

use std::process::Command;
use clap::{App, Arg, ArgMatches};

struct Ptools {
    add: String,
    remove: String,
    update: String,
    path: String,
    info: String,
    style: String,
    os: String,
    platform: String,
    copy: String,
}

impl Ptools {
    // Constructor 
    fn new(add: String, remove: String, 
        update: String, path: String, 
        info: String, style: String, 
        os: String, platform: String, 
        copy: String) -> Ptools {
        Ptools { add, remove, update, path, info, style, os, platform, copy } 
    }
    
    // Getters
    fn get_path(&self) -> &str {
        &self.path
    }

    fn get_info(&self) -> &str {
        &self.info
    }

    fn get_style(&self) -> &str {
        &self.style
    }

    // Setters
    fn set_path(&mut self, shell: String) {        
        let mut arg: &str;
        if shell == "sh" { arg = "-c"; } else if shell == "cmd" { arg = "/C"; } else { arg = "None"; }

        let output = Command::new(shell).arg(arg).arg("pwd").output().expect("[-] Command failed!");
        let path = String::from_utf8(output.stdout).expect("[-] Failed to parse stdout as UTF-8."); 
        let pattern = "/ptools";

        if let Some(index) = path.find(pattern) {
            let new_path = &path[..index];
            self.path = new_path.to_string() + "/" + &self.os + "/" + &self.platform + "/" + &self.style + "/";
        }
    }

    fn set_style(&mut self, style: String) {
        self.style = style;
    }
    
    fn set_os(&mut self, os: String) {
        self.os = os;
    }

    fn set_platform(&mut self, platform: String) {
        self.platform = platform;
    }

    fn set_info(&mut self) {
        self.info = format!("\nNAME: {}\nSTYLE: {}\nOS: {}\nPLATFORM: {}\nPATH: {}", 
            "temp_name".to_string(),&self.style, &self.os, &self.platform, &self.path);
    }

    // Core Functionality 
    fn add(&mut self, url: &str) {
        let mut command = format!("wget {} -P {}", url, &self.path);
        let wget = Command::new("sh")
            .arg("-c")
            .arg(command)
            .output()
            .expect("[-] Invalid link or path"); 
    }

    fn remove(&mut self) {

    }

    fn update(&mut self) {

    }
}


fn detect_supported_shell() -> &'static str {
    let win_shell = "cmd";
    let win_arg = "/C";

    let lin_shell = "sh";
    let lin_arg = "-c";
    
    // Detect os and handle errors
    let win_detect = Command::new(win_shell)
        .arg(win_arg)
        .arg("whoami")
        .output();
    
    match win_detect {
        Ok(_) => {
            // If primary command succeeds
            "cmd"
        },
        Err(_) => {
            // If primary command fails
            let lin_detect = Command::new(lin_shell)
                .arg(lin_arg)
                .arg("whoami")
                .output();

            match lin_detect {
                // If secondary command succeeds
                Ok(_) => {
                    "sh"
                },
                // If secondary command fails
                Err(_) => {
                    "None"
                },
            }
        },
    } 
}

fn get_matches() -> ArgMatches {
    App::new("Ptools")
        .version("1.0")
        .author("Author: macfra")
        .about("Program: Add, Remove, and Update useful programs/scripts for pentesting purposes")
        .arg(
            Arg::with_name("add")
            .short('a')
            .long("add")
            .help("add new program/script")
            .takes_value(true),
        )
        .arg(
            Arg::with_name("remove")
            .short('r')
            .long("remove")
            .help("remove existing program/script")
            .takes_value(true), 
        )
        .arg(
            Arg::with_name("update")
            .short('u')
            .long("update")
            .help("update existing program/script")
            .takes_value(true),
        )
        .arg(
            Arg::with_name("style")
            .short('s')
            .long("style")
            .help("Area of usage, eg: enumeration, privesc, exploitation")
            .takes_value(true),
        )
        .arg(
            Arg::with_name("os")
            .short('o')
            .long("os")
            .help("Operating System target: windows, linux")
            .takes_value(true)
        )
        .arg(
            Arg::with_name("platform")
            .short('p')
            .long("platform")
            .help("Platform target: x86, x64")
            .takes_value(true)
        )
        .get_matches()
}

fn get_specified_arguments(matches: &ArgMatches) -> Vec<(String, String)> {
    let args = [
        "add",
        "remove",
        "update",
        "style",
        "os",
        "platform",
    ];

    args.iter()
        .filter_map(|&arg| {
            if let Some(value) = matches.value_of(arg) {
                Some((arg.to_string(), value.to_string()))
            } else {
                None
            }
        }).collect()
}

fn check_arguments(specified_args: Vec<(String, String)>) -> String {
    let mut specified_args_vec: Vec<String> = Vec::new();
    
    // add requried flags for add to check if all flags used
    let mut okd_add_vec: Vec<String> = Vec::new();
    okd_add_vec.push("os".to_string());
    okd_add_vec.push("platform".to_string());
    okd_add_vec.push("style".to_string());
    okd_add_vec.push("add".to_string());

    for (arg, value) in &specified_args {
        specified_args_vec.push(arg.to_string());
    }

    for (arg, value) in &specified_args {
        if arg == "add" {
            let all_exist = okd_add_vec.iter().all(|item| specified_args_vec.contains(item));             
            if all_exist {
                println!("[+] All required flags for 'add'");
                return "add".to_string()
            } else {
                println!("[-] Missing flags, required: --os, --platform, --style");
            }
        } else if arg == "remove" {
            return "remove".to_string()
        } else if arg == "update" {
            return "update".to_string()
        } else {
            println!("[-] Something went wrong, perhaps you're not using the correct arguments/flags.");
        }
    }
    return "None".to_string()
}

fn main() {
    let matches = get_matches();
    let specified_args = get_specified_arguments(&matches);
    
    // Check specified args for missing flags/arguments
    let core_func = check_arguments(specified_args.clone());
    if core_func == "add" {
        println!("[+] Continueing --> add");
    } else if core_func == "remove" {
        println!("[+] Continueing --> remove");
    } else if core_func == "update" {  
        println!("[+] Continueing --> update");
    } else {
        println!("[-] Missing arguments/flags required, DO: ptools -h for more information.");
        std::process::exit(0)
    }
 
    // Detect supported shell to check for path
    let shell = detect_supported_shell().to_string(); 

    // Create target object (handles core functionality)
    let mut target = Ptools::new(
        String::from("Add:None"),
        String::from("Remove:None"),
        String::from("Update:None"),
        String::from("Path:None"),
        String::from("Info:None"),
        String::from("Style:None"),
        String::from("OS:None"),
        String::from("Platform:None"),
        String::from("Copy:None"));
    
    // Set attributes
    let mut url: String = "TEMP".to_string();
    for (arg, value) in specified_args {
        if arg == "os" {
            target.set_os(value.to_string());
        } 
        if arg == "style" {
            target.set_style(value.to_string());
        } 
        if arg == "platform" {
            target.set_platform(value.to_string());
        }
        if arg == "add" {
            url = value.to_string();
        }
        if arg == "remove" {
            // add here later
        }
        if arg == "update" {
            // add here later
        }
    }
    target.set_path(shell);
     
    // Set information & get information based on arguments/flags
    target.set_info();
    target.get_info();

    // Core Functionality (add, remove, update)
    target.add(&url);
    
    println!("{}",target.get_info());
}
