/* =========== INFO ABOUT PROGRAM =========== */
/* Author: macfra                             */
/* Description:                               */
/* this program is used to download & add,    */
/* download & update or remove specific files */
/* and programs used for enumeration, privesc,*/
/* and exploitation within this repo.         */
////////////////////////////////////////////////

use std::process::Command;
use clap::{App, Arg, ArgMatches};

struct Ptools {
    add: String,
    remove: String,
    update: String,
    path: String,
    info: String,
    style: String,
    os: String,
    platform: String,
    copy: String,
}

impl Ptools {
    // Constructor 
    fn new(add: String, remove: String, 
        update: String, path: String, 
        info: String, style: String, 
        os: String, platform: String, 
        copy: String) -> Ptools {
        Ptools { add, remove, update, path, info, style, os, platform, copy } 
    }
    
    // Getters
    fn get_path(&self) -> &str {
        &self.path
    }

    fn get_info(&self) -> &str {
        &self.info
    }

    fn get_style(&self) -> &str {
        &self.style
    }

    // Setters
    fn set_path(&mut self, shell: String) {        
        let mut arg: &str;
        if shell == "sh" { arg = "-c"; } else if shell == "cmd" { arg = "/C"; } else { arg = "None"; }

        let output = Command::new(shell).arg(arg).arg("pwd").output().expect("[-] Command failed!");
        let path = String::from_utf8(output.stdout).expect("[-] Failed to parse stdout as UTF-8."); 
        //TODO: remove the two /src/debug...
        //add to the path /here/is/the/new/path/style/os/platform
        println!("{}", path);

        self.path = path;
    }

    fn set_style(&mut self, style: String) {
        self.style = style;
    }
    
    fn set_os(&mut self, os: String) {
        self.os = os;
    }

    fn set_platform(&mut self, platform: String) {
        self.platform = platform;
    }

    fn set_info(&mut self, platform: String, style: String, os: String, path: String) {
    }

    // Core Functionality 
    fn add(&mut self) {
        
    }

    fn remove(&mut self) {

    }

    fn update(&mut self) {

    }
}


fn detect_os() -> &'static str {
    let win_shell = "cmd";
    let win_arg = "/C";

    let lin_shell = "sh";
    let lin_arg = "-c";
    
    // Detect os and handle errors
    let win_detect = Command::new(win_shell)
        .arg(win_arg)
        .arg("whoami")
        .output();
    
    match win_detect {
        Ok(_) => {
            // If primary command succeeds
            "cmd"
        },
        Err(_) => {
            // If primary command fails
            let lin_detect = Command::new(lin_shell)
                .arg(lin_arg)
                .arg("whoami")
                .output();

            match lin_detect {
                // If secondary command succeeds
                Ok(_) => {
                    "sh"
                },
                // If secondary command fails
                Err(_) => {
                    "None"
                },
            }
        },
    } 
}

fn get_matches() -> ArgMatches {
    App::new("Ptools")
        .version("1.0")
        .author("Author: macfra")
        .about("Program: Add, Remove, and Update useful programs/scripts for pentesting purposes")
        .arg(
            Arg::with_name("add")
            .short('a')
            .long("add")
            .help("add new program/script")
            .takes_value(true),
        )
        .arg(
            Arg::with_name("remove")
            .short('r')
            .long("remove")
            .help("remove existing program/script")
            .takes_value(true), 
        )
        .arg(
            Arg::with_name("update")
            .short('u')
            .long("update")
            .help("update existing program/script")
            .takes_value(true),
        )
        .arg(
            Arg::with_name("style")
            .short('s')
            .long("style")
            .help("Area of usage, eg: enumeration, privesc, exploitation")
            .takes_value(true),
        )
        .arg(
            Arg::with_name("os")
            .short('o')
            .long("os")
            .help("Operating System target: windows, linux")
            .takes_value(true)
        )
        .arg(
            Arg::with_name("platform")
            .short('p')
            .long("platform")
            .help("Platform target: x86, x64")
            .takes_value(true)
        )
        .get_matches()
}

fn get_specified_arguments(matches: &ArgMatches) -> Vec<(String, String)> {
    let args = [
        "add",
        "remove",
        "update",
        "style",
        "os",
        "platform",
    ];

    args.iter()
        .filter_map(|&arg| {
            if let Some(value) = matches.value_of(arg) {
                Some((arg.to_string(), value.to_string()))
            } else {
                None
            }
        }).collect()
}

fn check_arguments(specified_args: Vec<(String, String)>) {
    let mut specified_args_vec: Vec<String> = Vec::new();

    let mut okd_add: Vec<String> = Vec::new();
    okd_add.push("os".to_string());
    okd_add.push("platform".to_string());
    okd_add.push("style".to_string());

    for (arg, value) in specified_args {
        specified_args_vec.push(arg);
    }

    for (arg, value) in specified_args {
        if arg == "add" {
            let all_exist = specified_args_vec.iter().all(|item| okd_add.contains(item));             
            if all_exist {
                println!("TRUE SO TRUE!");
            } else {
                println!("lol what");
            }
        } else if arg == "remove" {

        } else if arg == "update" {

        } else {
            None
        }
    }
}

fn main() {
    let matches = get_matches();
    let specified_args = get_specified_arguments(&matches);
    check_arguments(specified_args);

    let shell = detect_os().to_string(); 
    let mut target = Ptools::new(
        String::from("Add:None"),
        String::from("Remove:None"),
        String::from("Update:None"),
        String::from("Path:None"),
        String::from("Info:None"),
        String::from("Style:None"),
        String::from("OS:None"),
        String::from("Platform:None"),
        String::from("Copy:None"));      
    
    // Set attributes
    //target.set_platform(platform);
    //target.set_style(style);
    //target.set_os(os);
    target.set_path(shell);
    //target.set_info(platform,style,os,shell);

    // Core Functionality
    //TODO:
    // depending on flags/arguments do add/remove/update/list(later)
    
    println!("{}",target.get_info());
}
